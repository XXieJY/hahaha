贪心算法的基本要素：
1. 贪心选择性质：所求问题的整体最优解可以通过一系列局部最优的选择得到，这是贪心算法可行的第一个基本要素，对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终能够导致问题的整体最优解

2. 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质，这是一个问题可用动态规划算法或贪心算法求解的关键特征


贪心法的步骤
1. 创建数学模型来描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。


贪心算法能否全局最优
1. 贪心算法得到的结果不能保证全局最优.因为贪心算法只能保证在每一步选择中都采取在当前状态下最优的选择，目的是希望由此导出的果是最优的，但不一定是全局最优的。

贪心算法与动态规划的区别
1. 贪心算法和动态规划本质上是对子问题树的一种修剪，两种算法要求问题都具有的一个性质就是子问题最优性，即最终组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的。

2. 动态规划算法：
    * 如果以自顶向下的方向看问题树（原问题作根），则我们每次只需要向下遍历代表最优解的子树就可以保证会得到整体的最优解。

    * 动态规划方法代表了这一类问题的一般解法，我们自底向上构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为当前自身的值，因此可以说每一步的最优解是由之前的局部最优解进行选择得到的，因为代表子问题的子树和叶子节点的遍历顺序有先后之分，所以在整个子问题局部最优解的遍历过程中需要保存之前所有子问题的最优解备查。
    * 动态规划的代价就取决于可选择的数目（树的叉数）和子问题的的数目。

3. 贪心算法：
    * 而贪心算法是动态规划方法的一个特例。一个贪心可解的问题必须要可以证明每一个子树的根的值不取决于下面叶子的值（即当前子问题的最优解不取决于其包含的更小子问题的最优解，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。

    * 由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。也就是说下一步(左右子节点)的最优解仅由上一步(子树的根节点)的最优解推导取得即当前最优解包含上一步的最优解，但是上一步之前的最优解则不作保留，因此在贪心算法中作出的每步决策都无法改变，不能回退。

    * 这样，与动态规划相比，它的代价只取决于子问题的数目，而可选择数目总为1（求解路径只会有一条）。

    * 贪心法可以解决一些最优化问题。但是对于更多的最优化问题，贪心法一般不能得到我们所要求的答案。**一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。**




4. 贪心算法本质上是一种（更快的）动态规划算法
    * 贪心法正确的条件是每一步的最优解一定包含上一步的最优解；

    * 贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

    * 如果可以证明：在递归求解的每一步，按贪心选择策略选出的局部最优解，最终可导致全局最优解，则二者是等价的





