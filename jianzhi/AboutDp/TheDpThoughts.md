## DP概述  
DP(Dynamic Programming)是算法设计中解决最优化问题(eg: 最长公共子序列)的重要思想。

> 动态规划的本质，是对问题状态的定义和状态转移方程的定义。  
——什么是动态规划？动态规划的意义是什么？(徐凯强 Andy的回答)


#### 如何很好地学习动态规划
1. 要深入理解并灵活运用dp必须要先对穷举和分治有很好的基础。
2. 这样才能灵活地通过拆分问题来定义问题状态和状态间的关系，从而使得问题能够以递推或者分治的方式去解决。
3. 否则就会陷入LRJ指出的一种现象：“每次碰到新题自己都想不出来，但一看题解就懂”的尴尬情况。
———(张广怡的回答)

### 从穷举为起点运用动态规划思路
* 我往往先考虑最朴素的穷举思路，并努力发现隐藏其中的“最优子结构”，寻找子问题的递推关系。


#### 以LCS最长公共子串举例：

1. 首先运用穷举思路来划分子问题：
 * 假设两个字符串为a, b，最后结果为子串s。
 * 按枚举的思路，对a的每一个字符进行枚举，假设它作为公共子串的首字符，并在b中从左往右寻找与它相同的字符。
 * 假设a[i]==b[j]，这样就得出子问题——现在问题变成了求a, b匹配字符的后缀的LCS，即lcs(a+i+1, b+j+1)。



LCS例子+分析：
```cpp
// example
// string a = “a1b2c3d4e”, b = “zz1yy2xx3ww4vv”;
// cout << lcs(a, b, 0, 0, 0); 
int lcs(string &a, string &b, int ia, int ib, int cur) {
    int max = cur;
    for (int i= ia; i<a.length(); i++) {
        char c = a[i];
        int j;
        for (j= ib; j<b.length(); j++) {
            if (c == b[j])
                break;
        }
        if (j == b.length()) continue;
        int ans = lcs(a, b, i+1, j+1, cur+1);
        if (ans > max) max = ans;
    }
    return max;
}

```
* 以上的代码复杂度非常大，原因在于相同的lcs(a, b, i, j, cur)可能会被多次调用，比如lcs(a, b, 3, 4, 1)和lcs(a, b, 3, 4, 2)（数据乱编的），它们的目的都是相同的——想求得lcs(a+i, b+j)。

* 发现穷举过程中隐藏的子模式＼子问题之后，可以把中间结果先算出来，并且它们正好可以存在一个二维表中，代码如下：
```cpp
const int N = 100;
int mat[N][N];
int lcs_dp(string &a, string &b) {
    fill(&mat[0][0], &mat[0][0]+N*N, 0);
    
    for (int i= a.length()-1; i>=0; i--) {
        for (int j= b.length()-1; j>=0; j--) {
            int &cur = mat[i][j];
            if (a[i] == b[j])
                cur = 1 + mat[i+1][j+1];
            else
                cur = mat[i][j+1]>mat[i+1][j] ? mat[i][j+1] : mat[i+1][j];
        }
    }
    return mat[0][0];
}
```

#### 关于穷举划分子问题法的提示：
* 有些子问题也穷举思路中也许不明显，需要读者自己去寻找一个划分点，然后创造重叠子问题。
* 本节问题的划分点是公共子串的第一个字符，再如“表达式链”问题（如UVA - 348）的划分点则是“最后一次运算”，都可以从穷举的思路中发现问题子模式。


#### Dp中如何使用穷举思维准确地剥离子问题：  
  * 首先拿到一个DP问题，我们最先要思考的是: 能够使当前问题规模缩小的“变数”在哪里？

  * 这里的“变数”很重要，**问题的“变数”往往是整个问题定义中的一个参数，当我们改变这个参数时，将会使问题的规模缩小。**
    * 例如，问题1的变数是数列A的大小，当我们改变数列A的大小时，问题1的规模变缩小了。因此，我们才这样剥离问题1:"F(x)是以A[x]为结尾的LIS的长度，且 0<= x <= N"。
    * 显然，此时若x 等于 N-1，我们把问题缩小了单位1长度；**此时若x等于0，我们则把问题的规模缩小成了0，显然此时还触碰到了当前问题的边界：“数列长度必须大于等于0”。**

    * 问题2中也可套用同样的思路: 我们可以把最终需要凑够的价格i元作为变数，当我们改变i元的大小时，问题2的规模同样被缩小了。
    * 因此我们才这样重新定义问题2:"D(i)是凑够i元需要的最少硬币个数"。**此时若i等于0，我们同样到达了当前问题的边界:"凑钱不可能凑出负数"。**


##### 关于“缓存”，“重叠子问题”，“记忆化”。  
这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。都不是动态规划的本质，不是动态规划的核心。


#### 无后效性和最优子结构：
先有一句话总结动态规划的性质：每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到，而不管之前这个状态是如何得到的。  
* 最优子结构：
  * 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到。
  * 如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。
* 无后效性:
  * 当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。
  * 而不管之前这个状态是如何得到的 --> 这个性质叫做无后效性；  
  * 无后效性数学特性：上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是"无后效性"的通俗上的数学定义。

#### 状态转移
> 从前面对剥离子问题的分析大抵可以感受到这么一个过程: 整个DP问题从问题的定义边界开始(比如: 数列之长度为0，凑钱之总额为0)，到问题收敛处为止(比如: 数列之长度为N，凑钱之总额为0)，**算法的每次决策都在推动前一个子问题发展到后一个子问题**，往往这种推动都有多种可能性

比如:A={1 7 2 8 3 4}，从当前F(3)={1，2}到F(6)时:
* 我们可以很机智地选择从F(5) = {1,2,3}走最优解到F(6)={1,2,3,4}。
* 但我们也可以任性地选择F(5)={1,2}到F(6)={1,2,4}，或者F(5)={1,2,3},F(6)={1,2,3}..以及其他多种可能性)。
* 此时我们可以在子问题之间以不同的状态(如F(5)={1,2,3} 或者F(5)={1,2})进行转移(比如从F(5)={1,2,3}到F(6)={1,2,3,4})，因此把子问题叫做“状态”，把子问题间的转移叫做“状态转移”是很形象的说辞。

动规解题的一般思路
1. **剥离子问题，获得状态(最需要技巧和训练的部分)**
    * 使用穷举思维尝试解题，并在穷举过程中探寻当前问题把原问题分解为若干个子问题的方法。
  
    * 子问题和原问题形式相同或类似，但是规模必须缩小。
  
    * 有些子问题也穷举思路中也许不明显，需要读者自己去寻找一个划分点，然后创造重叠子问题，最终都可以从穷举的思路中发现问题子模式。例如：
      * LCS问题的划分点是公共子串的第一个字符。
      * 再如“表达式链”问题（如UVA - 348）的划分点则是“最后一次运算”。
2. 确定状态的空间范围并明确状态的一些边界值  
    * 每个“子问题”的各个相关变量的一组取值称之为一个“状态”。

    * 所有可能的状态取值，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。

    * 且状态在“每次子问题的决策前后”发生转移。所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。

    * 以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。

3. 确定状态转移方程  
  * 状态转移方程需要明确定义出：
    * 边界状态的取值
    * 中间状态的最优转移过程的决策，在状态转移方程中出现的max(), min()就代表着一种最优决策。**我们如果把max或者min去掉，那么上面的方程式依然可以叫做状态转移方程，只是得到的结果不一定是最优解。**
例如：  
  ![image](https://upload-images.jianshu.io/upload_images/6115816-119f6f01bbe5f199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/422)    
  ![image](https://upload-images.jianshu.io/upload_images/6115816-d5c956035aff2310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/511)
   

4. 求解状态转移方程 
  * 首先我们需要定义存储子问题的最优解的矩阵存储空间。**比如伪代码中使用Min[i]数组存储每个子问题的最优解。**

  * 然后我们需要对DP问题的边界的解进行初始化。**比如伪代码中Min[0] = 0代表着边界条件"凑够0元需要的最少硬币数"的解。**

  * 定义好边界解后，我们就可以从边界解开始，使用递归的方法自底向上的求解DP的每个子问题，并把子问题的最优解记录下来。**比如，伪代码中从i = 1开始求解直到i = s,每次得到的子问题最优解都被存储在Min[i]中。**

  * 最后，根据特定的题目，或直接输出某个子问题的最优解，或对所有子问题的最优解进行处理以后再进行输出。**比如：硬币问题我们可以直接输出Min[11]。而LIS问题我们需要比较F(x),x = 0,1,2...N， 然后输出F(x)的最大值。**
![image](https://upload-images.jianshu.io/upload_images/6115816-f91096d5700add5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/639)  



 

