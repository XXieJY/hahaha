## DP概述  
DP(Dynamic Programming)是算法设计中解决最优化问题(eg: 最长公共子序列)的重要思想。

> 动态规划的本质，是对问题状态的定义和状态转移方程的定义。  
——什么是动态规划？动态规划的意义是什么？(徐凯强 Andy的回答)


### 如何很好地学习动态规划
> 《算法竞赛入门经典》中LRJ是按**“穷举－分治－dp”来安排书本章节的，这并非偶然，要深入理解并灵活运用dp必须要先对穷举和分治有很好的基础，这样才能灵活地通过拆分问题来定义问题状态和状态间的关系，从而使得问题能够以递推或者分治的方式去解决。****否则就会陷入LRJ指出的一种现象：“每次碰到新题自己都想不出来，但一看题解就懂”的尴尬情况。
———(张广怡的回答)

### 常见的动态规划题型
1. 求最大最小的问题

2. 判断可不可行,存不存在

3. 统计方案个数

### 常见使用DFS而不可用DP的题型：
1. 求所有的具体的方案而不是方案个数,要用DFS而不是DP

2. 输入数据是一个集合而非序列(70~80%不用DP)，除了背包问题。


### 贪心和动态规划的联系
贪心和动态规划是有联系的：
* 贪心是“最优子结构+局部最优”；
* 动态规划是“最优独立重叠子结构+全局最优”。

### 分析问题该用递推、贪心、搜索还是动态规划？
一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的：
* 每个阶段只有一个状态->递推；
* 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
* 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
* 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。


---

## 动态规划的求解
#### 1.动态规划整个理论是：
* 先**枚举所有状态**。  
 * (所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关)
* 然后**剪枝**
* 再**寻找最优状态**，
  * 同时将每一次求解子问题的结果保存在一张“表格”中；
  * 以后再遇到重叠的子问题，从表格中保存的状态中查找（俗称记忆化搜索）。

#### 2.动态规划求解具体过程
动规解题的一般思路
1. **剥离子问题，获得状态(最需要技巧和训练的部分)**
  * 将原问题分解为子问题  
把原问题分解为若干个子问题，子问题和原问题形式相同或类似，但是规模必须缩小。

  * 确定状态  
    * 从“原始的最优化问题”剥离出的每个“最优化子问题”相关的各个变量的一组取值称之为一个“状态”，因此每个"最优化子问题"都是当前DP问题的一个状态，每个状态分布在“每次的决策前后”。所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。

    * 一个“状态”对应于一个或多个子问题。而所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。

2. **确定一些初始状态值（边界状态值）**  
以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。

3. **确定状态转移方程**  
例如：  
  ![image](https://upload-images.jianshu.io/upload_images/6115816-119f6f01bbe5f199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/422)    

  ![image](https://upload-images.jianshu.io/upload_images/6115816-d5c956035aff2310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/511)
  * 定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何通过决策进行迁移
    * 即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。
  * 通常状态转移方程和当前问题的边界条件联立起来叫做状态转移方程式。
  * **在状态转移方程中出现的max(), min()就代表着一种最优决策。** 我们如果把max或者min去掉，那么上面的方程式依然可以叫做状态转移方程，只是得到的结果不一定是最优解。

4. **求解状态转移方程**  
![image](https://upload-images.jianshu.io/upload_images/6115816-f91096d5700add5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/639)  
  从伪代码我们可以分析出一个较为通用的DP代码实现过程：（S代表总额，N-1代表可能的硬币面值）

  * 首先我们需要存储每个子问题的最优解，比如伪代码中使用Min[i]数组存储每个子问题的最优解。

  * 然后我们需要对DP问题的边界的解进行初始化，比如伪代码中Min[0] = 0代表着边界条件"凑够0元需要的最少硬币数"的解。

  * 定义好边界解后，我们就可以从边界解开始，使用递归的方法自底向上的求解DP的每个子问题，并把子问题的最优解记录下来。比如，伪代码中从i = 1开始求解直到i = s,每次得到的子问题最优解都被存储在Min[i]中。

  * 最后，根据特定的题目，或直接输出某个子问题的最优解，或对所有子问题的最优解进行处理以后再进行输出。比如：硬币问题我们可以直接输出Min[11]。而LIS问题我们需要比较F(x),x = 0,1,2...N， 然后输出F(x)的最大值。

---

## 对动态规划更深入地理解

### Dp中如何准确地剥离子问题：  
  * 首先拿到一个DP问题，我们最先要思考的是: 该问题的“变数”在哪里？这里的“变数”很重要，**问题的“变数”往往是整个问题定义中的一个参数，当我们改变这个参数时，将会使问题的规模缩小。**
  * 例如，问题1的变数是数列A的大小，当我们改变数列A的大小时，问题1的规模变缩小了。因此，我们才这样剥离问题1:"F(x)是以A[x]为结尾的LIS的长度，且 0<= x <= N"。显然，此时若x 等于 N-1，我们把问题缩小了单位1长度；**此时若x等于0，我们则把问题的规模缩小成了0，显然此时还触碰到了当前问题的边界：“数列长度必须大于等于0”。**
  * 问题2中也可套用同样的思路: 我们可以把最终需要凑够的价格i元作为变数，当我们改变i元的大小时，问题2的规模同样被缩小了。因此我们才这样重新定义问题2:"D(i)是凑够i元需要的最少硬币个数"。**此时若i等于0，我们同样到达了当前问题的边界:"凑钱不可能凑出负数"。** 因此，DP剥离子问题需要多联系"当前问题中可能的变数"，同时多加练习。


### 递推式求解的技巧
##### 关于“缓存”，“重叠子问题”，“记忆化”。  
这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。都不是动态规划的本质，不是动态规划的核心。


### 递归：
* 递归是递推式求解的基本方法。  

### 无后效性和最优子结构：
先有一句话总结动态规划的性质：
* 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到，而不管之前这个状态是如何得到的。  
  * 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到 --> 这个性质叫做最优子结构；
  * 而不管之前这个状态是如何得到的 --> 这个性质叫做无后效性；  

### 无后效性
  * 定义：**当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。**
    * 无后效性特性的通俗理解：而不管之前这个状态是如何得到的 --> 这个性质叫做无后效性；


  * 无后效性数学特性：上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是"无后效性"的通俗上的数学定义。

### 最优子结构
1. 定义：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质

2. 注意点一：**在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。**

3. 注意点二：**需要注意的是，一个问题可能有多种不同的状态定义和状态转移方程定义，存在一个有后效性的定义，不代表该问题不适用动态规划。**
  * 因此：动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义，在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。

### 状态转移
> 从前面对剥离子问题的分析大抵可以感受到这么一个过程: 整个DP问题从问题的定义边界开始(比如: 数列之长度为0，凑钱之总额为0)，到问题收敛处为止(比如: 数列之长度为N，凑钱之总额为0)，**算法的每次决策都在推动前一个子问题发展到后一个子问题**，往往这种推动都有多种可能性

比如:A={1 7 2 8 3 4}，从当前F(3)={1，2}到F(6)时:
* 我们可以很机智地选择从F(5) = {1,2,3}走最优解到F(6)={1,2,3,4}。
* 但我们也可以任性地选择F(5)={1,2}到F(6)={1,2,4}，或者F(5)={1,2,3},F(6)={1,2,3}..以及其他多种可能性)。
* 此时我们可以在子问题之间以不同的状态(如F(5)={1,2,3} 或者F(5)={1,2})进行转移(比如从F(5)={1,2,3}到F(6)={1,2,3,4})，因此把子问题叫做“状态”，把子问题间的转移叫做“状态转移”是很形象的说辞。

---

参考资料：  
背包九讲  
[ref1](http://www.hawstein.com/posts/dp-novice-to-advanced.html)  
[ref2](https://www.zhihu.com/question/39948290)  
[ref3](https://www.zhihu.com/question/23995189)  
[ref4](http://blog.csdn.net/baidu_28312631/article/details/47418773)  
[ref5](http://blog.csdn.net/ii1245712564/article/details/45040037)  
[ref6](http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html)  
[ref7](http://blog.csdn.net/zccz14/article/details/51288079)  
[ref8](https://www.zhihu.com/question/23995189/answer/35429905)  
[ref9](https://stomachache007.wordpress.com/2017/04/09/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-9-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/)
